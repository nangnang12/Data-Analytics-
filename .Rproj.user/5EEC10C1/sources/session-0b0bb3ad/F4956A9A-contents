<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.557">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>week7_7.4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Week7_7.4_files/libs/clipboard/clipboard.min.js"></script>
<script src="Week7_7.4_files/libs/quarto-html/quarto.js"></script>
<script src="Week7_7.4_files/libs/quarto-html/popper.min.js"></script>
<script src="Week7_7.4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Week7_7.4_files/libs/quarto-html/anchor.min.js"></script>
<link href="Week7_7.4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Week7_7.4_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Week7_7.4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Week7_7.4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Week7_7.4_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="week-7.-kpi-design-concept-mvp" class="level1">
<h1>Week 7. KPI, Design Concept &amp; MVP</h1>
<p><br></p>
<p>6주 과제 리뷰&gt;</p>
<ol type="1">
<li>어피니티 다이어그램은 모든 데이터와 분석 인사이트를 종합하여 구축함.</li>
</ol>
<ul>
<li>문제 구조의 최상위 헤더가 문제(타겟 서비스)의 핵심을 설명하고 있는지 (명확함, 구체성 확보)</li>
</ul>
<ol start="2" type="1">
<li>어피니티 다이어그램을 통하여 가장 중요한 문제 2-3가지를 선정. 모든 문제를 다 해결할 수는 없음.</li>
<li>UI 문제, 경로 문제, 레이블 문제 등 앱 구성 요소의 문제는 주요 문제에서 제외</li>
<li>어피니티 다이어그램의 주요 문제가 KPI와 연계되도록 KPI를 설정, KPI가 주요 문제의 해결 여부를 판단할 수 있어야함.</li>
<li>KPI를 개선할 디자인 컨셉 제시 (데이터 분석 내용이 반영된 사용자 경험이어야함.)</li>
<li>타겟앱에서 디자인 개선할 개별 서비스나 페이지/ 사용자 시나리오 선정 (3-4 페이지)</li>
<li>KPI는 실제 사용데이터 수집이 가능한 경우(사용자 log 데이터가 있는 경우)의 KPI가 있고, 수업 상황 (실사용 데이터 수집이 불가한 경우)에 측정 가능한 KPI가 있음.</li>
<li>A/B 테스팅에서 사용할 KPI는 실사용 데이터 수집이 불가함을 고려하여 측정 방법을 선정함.</li>
</ol>
<ul>
<li>A/B testing은 두 디자인을 나란히 놓고 비교하는 것이 아님. 각 사용자는 A/B중 하나만 경험할 수 있음.</li>
<li>설문에 의한 KPI 측정은 평가 정확성이 떨어지므로 상세한 설문 설계가 필요함.</li>
</ul>
<p><br></p>
<p><span style="color: darkorange;">7주 과제 &gt;</span></p>
<ul>
<li>팀 별 Project Statement 정리</li>
</ul>
<p>(리서치한 데이터 내용의 oo 부분/ 활동) Data insight를 기반으로 (Target Service) 앱의 사용 상황 니즈를 반영하여(사용자 경험A), (사용자 경험B) 등을 수행하는 (서비스A), (서비스B) 부분을 개선한 리디자인을 제안한다. (+ 제안한 디자인은 정량적 평가를 통하여 앱 서비스의 개선 정도를 검증한다. )</p>
<ul>
<li>최종 어피니티 다이어그램</li>
<li>KPI가 디자인 목표가 되도록 내용 수정</li>
<li>KPI를 개선하는 디자인 컨셉 제시</li>
<li>개선 디자인 시안(MVP-Minimum Viable Product)을 디지털 스케치로 제안 (1차)— 팀원 각자 다른 아이디어로 진행 후 회의를 거쳐 최종안을 제시(2차) (팀원이 3명인 경우 4개의 안이 나오게 됨)</li>
<li>기존 디자인과 개선 디자인을 비교하여 볼 수 있도록 화면을 구성</li>
</ul>
<p>화면 디자인 피드백&gt; 폰의 디자인 패턴을 잘 알고 적용해야함.</p>
<p>네비게이션 구조 지키기, 텝 바 네비게이션은 사라지지 않음, 탭 바의 화면 중 하나는 반드시 열려있음. 햄버거 버튼 중복 사용 금지, 탭바와 함께 쓰지 않음 다른 앱 사용시 알림이 올 때는 알림센터 사용 (별도 디자인 불가) 화면 상단은 가장 중요한 내용을 배치 (의미 없는 이미지 금지) 앱 사용 시점에서 상황에 필요한 내용이 보이게함. 텍스트 필드는 키보드 위에 위치 모달뷰를 열면 닫는 UI필요, 각 뷰에 속하는 UI 컨트롤은 소속 뷰에만 해당함 label 네이밍 적합성 고려 버튼 크기가 너무 작으면 안됨, 버튼만 있는 빈 화면 만들지 말것, 버튼과 레이블의 역할 구분 현재 내가 설정한 정보 내용이 노출되도록함 드래그는 폰에서 어려운 인터렉션임 (사용 지양) 지도는 지도 정보를 활용 가능한 방법으로 표현, 지도에서 구역을 설정하거나 경로를 지정하는 것은 어려운 작업임 지도위에 복잡한 3D올리지 말것 앱의 텍스트는 상태바의 텍스트보다 작지 않게 긴스크롤 화면은 스크롤 여부를 예상할 수 있게 레이아웃</p>
<p>토글, 세그먼트 버튼의 표현 차별성에 유의, 같은 디자인은 같은 인터렉션이 되도록함. A화면, B화면의 콘텐츠가 같게함. 사용 상황이 일치하도록 하여 디자인만 비교되도록 함.</p>
<p><br></p>
<p>8주 과제 디자인 평가 (A/B 테스트) 기획서 &gt; 해설 추가</p>
<p>팀별 미팅 결과 반영하여 디자인 개선안(B안)을 수정 완료한 뒤,</p>
<ol type="1">
<li>평가 목적: 테스트할 항목(KPI)을 3개 이상, 테스트 항목 별 질문 또는 관찰할 내용을 2개 이상 제시</li>
<li>평가 내용1 : 각 테스트 항목마다 필요한 디자인 화면 (A화면, B화면)및 질문 원고, 응답 형식 제시 (Likert 7점 척도 사용)</li>
<li>평가 내용2: 디자인 개선에 도움이 될만한 추가 질문 원고 (정량/ 정성적 질문 모두 가능)</li>
<li>테스트 형식은 구글 설문지 양식을 사용하여 30명 이상 설문 진행 예정 (중간평가 이후 진행)</li>
</ol>
<p>(AB테스트 기획까지가 중간 평가 범위)</p>
<p><br></p>
<p>A/B 테스트 기획 고려사항&gt; 해설 추가</p>
<ul>
<li>사용자가 쉽게 이해할 수 있는 용어로 서술한다. 서비스의 전문 용어, 디자인의 전문 용어는 사용하지 않음. 꼭 필요한 서비스 용어는 미리 설명할것</li>
<li>질문은 존대말 사용. 현재형 질문 (예: 만족하시나요? (O), 만족하셨나요?(X)), 골라주세요—&gt;선택해주세요.</li>
<li>서비스의 사용 상황을 설명할 필요가 있으면 그 내용도 추가함. 사용 상황에 알맞은 콘텐츠 원고를(시간, 지역, 상태 등) 제공함. (예: 당신은 11월에 혼자 도쿄 여행을 준비하고 있습니다.)</li>
<li>A안과 B안의 페이지 수, 콘텐츠(텍스트 원고, 이미지, 테스트 대상이 아닌 GUI)를 동일하게 구성한다!!!!!</li>
<li>페이지 중심으로 평가를 하므로 Flow 중심의 검증은 한계가 있음.</li>
<li>A안에 전혀 포함되지 않은 내용이나 디자인을 질문하지 않는다. 객관적인 태도로 질문해야함.</li>
<li>폰 사이즈가 어색하지 않게 필요한 부분만 스크롤한 이미지로 비교함. (긴 스크롤 뷰를 사용하지 않음)</li>
<li>디자인 평가 대상이 아니어도 향후 디자인 개선을 위해 필요한 내용은 객관식이나 간단한 단답식 질문으로 추가 가능함. (평가 내용2, 예: 검색 결과에 추가 되었으면하는 내용은 어떤 것인가요?) 사용자 세그먼트 관련 정보를 질문할 수도 있음. (예: 사용하는 유사 앱, 일기쓰는 횟수 등)</li>
<li>사용자 구분이 필요한 경우 (예: heavy user, light user) 스크리닝을 미리하여 같은 세그먼트 사용자끼리만 비교해야함.</li>
<li>정성 평가와 정량 평가의 의미 구분. 정량 평가는 수치로 측정 가능하면 다 정량 평가임. 주관식 질문이 정성적 질문은 아님.</li>
<li>자연스러운 사용자 시나리오를 중심으로 화면 순서를 배치하고, 각 화면에 관련한 질문(kpi 관련 질문, 추가 질문 모두)을 배치, 질문 배정이 kpi 중심이 아님, 질문 번호 이어서 쓸 것 (화면 별로 분리하지 않음)</li>
<li>구글 설문 폼은 리커트의 디자인 자유도가 제한적임</li>
</ul>
<p><br></p>
<section id="중간-발표-준비-금요일반-11월-3일-목요일반-11월-9일" class="level3">
<h3 class="anchored" data-anchor-id="중간-발표-준비-금요일반-11월-3일-목요일반-11월-9일">중간 발표 준비 (금요일반 11월 3일, 목요일반 11월 9일)</h3>
<ol type="1">
<li>Project Statement (cover page)</li>
<li>Target Data Implication(1-2p)</li>
<li>Target App (1-2p)</li>
<li>Design Research, KPI (1-2p)</li>
<li>Redesign Concept (1p)</li>
<li>MVP Redesign (Designed pages)</li>
<li>A/B Test Goal (1-2p, KPI당 테스트, 질문 항목을 2개 이상 제시)</li>
<li>Test Prototype and Questionnaire (by View)</li>
</ol>
<p>제한 시간까지 발표자료가 클래스룸 제출되지 않은 팀은 발표할 수 없습니다.</p>
<p>발표 시간은 팀당 10분 이내입니다.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>