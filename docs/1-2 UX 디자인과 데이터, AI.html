<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR" xml:lang="ko-KR"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; 1-2. UX 디자인과 데이터, AI – bitPublish를 이용하여 한글 책 조판하기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./1-3 데이터 기반 디자인 (Data Driven Design).html" rel="next">
<link href="./1-1 UX 디자인의 오늘과 변화의 방향.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./1-2 UX 디자인과 데이터, AI.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1-2. UX 디자인과 데이터, AI</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="검색" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">bitPublish를 이용하여 한글 책 조판하기</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">머릿말: 이 책에서 다루는 것과 다루지 않는 것</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1-1 UX 디자인의 오늘과 변화의 방향.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">1-1. UX 디자인의 오늘과 변화의 방향</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1-2 UX 디자인과 데이터, AI.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1-2. UX 디자인과 데이터, AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1-3 데이터 기반 디자인 (Data Driven Design).html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">1-3. 데이터 기반 디자인 (Data Driven Design)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">참고문헌</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#데이터의-시각으로-해석한-디자인" id="toc-데이터의-시각으로-해석한-디자인" class="nav-link active" data-scroll-target="#데이터의-시각으로-해석한-디자인"><span class="header-section-number">3.0.1</span> 데이터의 시각으로 해석한 디자인</a></li>
  <li><a href="#데이터와-ai의-관계" id="toc-데이터와-ai의-관계" class="nav-link" data-scroll-target="#데이터와-ai의-관계"><span class="header-section-number">3.0.2</span> 데이터와 AI의 관계</a></li>
  <li><a href="#ux-디자인-대상으로서의-ai와-ux-디자인-도구로서의-ai" id="toc-ux-디자인-대상으로서의-ai와-ux-디자인-도구로서의-ai" class="nav-link" data-scroll-target="#ux-디자인-대상으로서의-ai와-ux-디자인-도구로서의-ai"><span class="header-section-number">3.0.3</span> UX 디자인 대상으로서의 AI와 UX 디자인 도구로서의 AI</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1-2. UX 디자인과 데이터, AI</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="데이터의-시각으로-해석한-디자인" class="level3" data-number="3.0.1">
<h3 data-number="3.0.1" class="anchored" data-anchor-id="데이터의-시각으로-해석한-디자인"><span class="header-section-number">3.0.1</span> 데이터의 시각으로 해석한 디자인</h3>
<p>UX 디자인에서 데이터를 사용하는 것은 새로운 현상이 아닙니다. 디자인 과정에서 데이터는 언제나 사용되어 왔습니다. 우리가 수행하는 디자인 리서치는 대부분 디자인 주제와 관련한 데이터를 수집하는 것으로 시작됩니다. 그리고 디자이너는 수집한 데이터를 검토하여 필요한 데이터를 선정하고, 선정된 데이터를 사용하여 디자인에 적용할 수 있는 형태의 의미있는 데이터로 변환합니다. 디자인에 적용할 수 있는 형태의 데이터에는 설문이나 관찰 조사된 데이터의 분석 보고서도 있고, 데이터의 내용을 시각적으로 표현한 그래프나 다이어그램, 디자이너가 추출한 인사이트, 그리고 디자이너가 제작한 문제의 구조 다이어그램도 있을 것입니다. 또한 디자인 콘셉트를 표현한 스케치나 도면도 데이터가 됩니다. 그리고 이러한 의미있는 디자인 데이터들은 디자이너의 의도에 의하여 목표하는 디바이스나 플랫폼에서 작동하는 화면 레이아웃이나 버튼, 인터렉션을 발생하는 이벤트 등의 디자인 구현 데이터들로 변환되어 디지털 서비스의 개발 코드에 사용됩니다. 결국 데이터의 시각에서 디자인 과정을 해석하면, 디자인이란 디자인 주제와 관련한 다양한 데이터 재료들을 적절한 방법으로 변환하는 과정을 통하여 디자인 해결안을 구축하는 구현 데이터를 생성하는 과정이라고 말할 수 있습니다.</p>
<p>다만 이 과정에서 사용하는 데이터는 내용과 형식면에서 매우 다양하고, 넓은 범위에 있어서, 데이터들을 선정하고, 해석하고, 필요한 형태로 전환하는 작업들이 디자이너의 주관적이고 창의적인 활동 역량에 의존적이라는 특징이 있습니다. 이와같이 기존의 디자인 방법론도 데이터를 사용하여 디자인을 해왔지만, 최근 주목받는 데이터 기반 디자인(Data Driven Design)의 다른 점은 디자인에 사용하는 데이터들을 디지털화 함으로써 대규모의 데이터를 소프트웨어적인 방법으로 통합, 변형하거나 관리하는 것이 가능한 점, 다양하고 생산성 높은 과학적 분석 기법들을 적용할 수 있는 점, 디자인 내부에서 뿐 아니라 여러 관련 분야의 조직들이 협업하여 이 데이터들을 공유하고 재구성할 수 있다는 점이 다릅니다. 데이터 기반 디자인은 디자인 활동의 내용 측면에서는 기존의 디자인 방법과 동일하지만, 프로젝트에 사용하는 데이터를 수집하고, 가공하고, 활용하는 방법에 변화가 따르게 됩니다.</p>
</section>
<section id="데이터와-ai의-관계" class="level3" data-number="3.0.2">
<h3 data-number="3.0.2" class="anchored" data-anchor-id="데이터와-ai의-관계"><span class="header-section-number">3.0.2</span> 데이터와 AI의 관계</h3>
<p>최근 디자인을 위한 데이터들이 관심을 받게 된 배경에는 인공지능의 출현이 있습니다. 인공지능 서비스의 본질은 서비스의 제공에 필요한 데이터를 수집하고 이를 인간의 사고 과정과 유사한 데이터 모델로 처리하여 결과를 목표하는 데이터 형식으로 출력하는 과정, 즉 인간이 원하는 가치를 얻어내기 위하여 데이터의 입력, 처리, 출력의 라이프사이클을 인공지능을 사용하여 관리하는 기술이라고 할 수 있는데, 서술하는 바와 같이 인공지능 서비스를 가능하게 하는 기본 재료는 ’데이터’입니다. 인간의 사고 과정과 유사한 데이터 모델(인공지능)을 구축하기 위하여는 인간이 데이터를 처리하는 방법을 다량의 데이터로 학습하는 과정이 필요합니다. 이러한 학습 과정을 통하여 인공지능은 인간처럼 대화하고, 판단하고, 예측할 수 있게 됩니다. 그리고 학습 데이터의 질과 양에 따라서 인공지능의 능력이 달라지므로, 인공지능의 역량을 높이기 위해서 양질의 데이터를 다량으로 학습시키고, 테스트하는 과정이 동반됩니다. 그러므로 어떤 인공지능 서비스를 개발할 때는 어떤 데이터를 어떻게 학습시켜서 우리가 원하는 능력을 갖는 인공지능 모델을 구축할 지에 대한 기술적인 이해가 필요하고, 인공지능 서비스를 개발하는 디자이너라면 사용자, 인공지능 데이터 모델, 구현 서비스 간의 통합적인 접점을 제공하는 UX디자인을 제시할 수 있어야 합니다. 기존에 사용자와 구현 서비스간의 UX를 디자인하는 일에 인공지능 데이터 모델이라는 요소가 추가되어 더욱 다면적인 UX 디자인이 요구되는 것입니다.</p>
<p>[그림1] 다이어그램 추가 필요 (데이터, UX디자인, 서비스, AI)</p>
</section>
<section id="ux-디자인-대상으로서의-ai와-ux-디자인-도구로서의-ai" class="level3" data-number="3.0.3">
<h3 data-number="3.0.3" class="anchored" data-anchor-id="ux-디자인-대상으로서의-ai와-ux-디자인-도구로서의-ai"><span class="header-section-number">3.0.3</span> UX 디자인 대상으로서의 AI와 UX 디자인 도구로서의 AI</h3>
<p>본 교재의 학습 주제는 데이터 기반 디자인이므로 UX 디자인과 AI의 두가지 연결 지점에서 사용하는 데이터의 특징을 살펴보겠습니다. 첫번째 연결 지점은 인공지능 서비스가 UX 디자인의 대상이 되는 경우, 즉 인공지능 서비스 개발을 위한 UX 디자인을 하는 지점입니다. 이 경우에 디자이너가 다루는 데이터는 인공지능 서비스가 학습하고, 테스트하고, 수집하는 사용자 및 서비스 관련 데이터가 디자인의 대상이 됩니다. 보통 디자이너는 인공지능 서비스 개발에서 사용자가 접하는 화면 그래픽(GUI)이나 인터렉션을 디자인하는 업무에 한정된다고 생각하기 쉽지만, 인공지능 서비스가 어떤 사용자 경험을 수집하고 이해해야 효과적인 서비스가 가능한지를 판단하려면 인공지능 모델 개발의 초기 단계부터 UX 디자이너가 참여해야합니다.</p>
<p>디자이너는 인공지능 모델을 구축할 때 인공지능이 학습할 데이터의 내용과 형식에 대하여 이해하고, 서비스의 환경과 사용자 상황에 맞는 학습 데이터를 선정하는 일에 참여합니다. 또한 인공지능 모델이 구축된 후에 성능을 테스트하고, 서비스의 완성도를 검증하는 일에도 참여해야합니다. 그리고 인공지능 서비스가 제공될 때, 사용자가 서비스와 잘 소통하고, 서비스 내용을 이해할 수 있는 사용자 접점을 디자인해야 합니다. 마지막으로 사용자의 피드백데이터를 기반으로 인공지능 모델과 서비스를 개선할 수 있는 디자인을 제시하여 서비스의 성장을 이끌게 됩니다. 이렇게 UX 디자이너는 인공지능 서비스 개발과 운영, 평가의 전반에 사용자 경험을 반영하여 서비스의 질을 확보하는 중요한 역할을 하고, 이를 위하여 서비스 전체 과정에서 사용되고, 생성되는 데이터에 대한 문해력이 필요하고, 인공지능 모델 개발자, 서비스 개발자 등 기술 전문가와의 협업 능력도 요구됩니다. 마찬가지로, 디자이너와의 효과적인 협업을 위하여 기술 전문가들도 사용자 경험과 디자인을 이해하는 역량이 요구되고 있습니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="1-2 UX 디자인과 데이터, AI e536b52818b34fc69680f8f78a377d76/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.39.36.png" class="img-fluid figure-img"></p>
<figcaption>[그림2] 사용자의 청취 기록을 분석하여 ’Discover Weekly’와 같은 맞춤형 콘텐츠를 제공하는 글로벌 음악 스트리밍 서비스, Spotify(3)</figcaption>
</figure>
</div>
<p>[그림2] 사용자의 청취 기록을 분석하여 ’Discover Weekly’와 같은 맞춤형 콘텐츠를 제공하는 글로벌 음악 스트리밍 서비스, Spotify(3)</p>
<p>두번째, 인공지능은 UX 디자인을 위한 도구 역할을 할 수 있습니다. 데이터 분석과 시각화, 아이디어 도출, 디자인 레이아웃 제안, 그래픽 시안 제작 등 디자인 프로세스의 여러 활동들이 인공지능 기술을 활용한 디자인 서비스로 제공되고 있고, 디자인하는 인공지능 서비스는 앞으로도 영역을 확장하여 발전해 나갈 것입니다. 인공지능 기술을 활용한 디자인 방법은 디자인의 생산성을 높이는 데 크게 기여하고 있습니다. 인공지능 기술은 디자이너의 사고와 작업 방식을 학습하여 디자이너처럼 데이터를 처리하고 그 결과물을 제안합니다. 이러한 상황에서 디자이너들이 기술을 더 잘 활용하고, 디자인의 역량을 확대하기 위해서는 디자인하는 인공지능 기술들이 데이터를 처리하는 방법을 이해하고 활용할 수 있어야하며, 나아가 인공지능이 더 높은 수준의 디자인 작업을 지원할 수 있도록 디자인 데이터와 디자인 행위를 데이터 기술과 연계하는 방법을 개발할 필요가 있습니다.</p>
<p>아래의 기사는 UX 디자인 업무에 AI 서비스를 사용하는 구체적인 업무 내용과 방법들을 설명하고 있습니다. (4)</p>
<p><a href="https://www.nngroup.com/articles/ai-ux-getting-started/">AI for UX: Getting Started</a></p>
<p>2024년 7월에는 대표적인 UX/UI 표현 도구인 피그마에서 AI 기술을 적극적으로 활용한 디자인과 개발, 프레젠테이션 기능들을 선보였습니다. (5)</p>
<p><a href="https://help.figma.com/hc/ko/articles/24037640924823-Config-2024에서-발표된-새로운-기능">Config 2024에서 발표된 새로운 기능</a></p>
<p>이렇게 UX 디자인에 인공지능 기술이 들어와 디자이너의 업무를 수행하게 된다면 어떤 일들이 벌어질까요? 인공지능이 디자인을 할 수 있으므로 디자이너의 일자리가 없어질까요? 인공지능이 담당할 수 없는 창의적이고, 모험적인 업무에는 소수의 디자이너가 주도하고, 인공지능이 디자이너의 업무를 대신하는 것이 가능한 단순 반복적 디자인 작업이나 패턴화된 디자인 작업은 사람대신 인공지능이 대체하게 될 것입니다. 또 많은 디자이너들은 인공지능에게 할 일을 지시하거나 인공지능의 결과물을 검수하는 일, 그리고 인공지능이 디자인 업무를 할 수 있도록 디자인 업무를 디지털 데이터 중심으로 변환하고, 패턴화하는 일을 하거나, 인공지능에게 학습 데이터를 제공하는 일들을 하게 될 것입니다. 이렇게 인공지능 기반 디자인 도구들은 디자이너의 업무 내용이나 업무 역량의 변화를 이끌고, 디자인 전문가가 아닌 사람들과 디자인 업무의 협업자들이 인공지능 서비스를 활용하여 쉽게 UX 디자인 문제들을 해결하게 할 것으로 예상합니다. 기술은 본래 의식이 없습니다. 기술이 우리에게 긍정적인 역할을 할지, 부정적인 역할을 할지는 인간의 사용 의도에 따라 달라질 수 있습니다. 디자이너는 중립적인 인공지능 기술이 우리에게 유리한 방향으로 기여하도록 잘 이끌어 가야 하겠습니다.</p>
<p>(문헌 3) Spotify(스포티파이), Apple app store</p>
<p>(문헌 4) Kate Moran, Jakob Nielsen, “<strong>AI for UX: Getting Started”,</strong> <a href="https://www.nngroup.com/articles/ai-ux-getting-started/" class="uri">https://www.nngroup.com/articles/ai-ux-getting-started/</a>, (2023)</p>
<p>(문헌 5) Figma Learn, “<strong>Config 2024에서 발표된 새로운 기능”,</strong> <a href="https://help.figma.com/hc/ko/articles/24037640924823-Config-2024%EC%97%90%EC%84%9C-%EB%B0%9C%ED%91%9C%EB%90%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B8%B0%EB%8A%A5">https://help.figma.com/hc/ko/articles/24037640924823-Config-2024에서-발표된-새로운-기능</a>, (2024)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./1-1 UX 디자인의 오늘과 변화의 방향.html" class="pagination-link" aria-label="1-1. UX 디자인의 오늘과 변화의 방향">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">1-1. UX 디자인의 오늘과 변화의 방향</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./1-3 데이터 기반 디자인 (Data Driven Design).html" class="pagination-link" aria-label="1-3. 데이터 기반 디자인 (Data Driven Design)">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">1-3. 데이터 기반 디자인 (Data Driven Design)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>